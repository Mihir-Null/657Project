\documentclass[aspectratio=169]{beamer}
\usetheme{metropolis}

\setbeamertemplate{section in toc}{\textbullet\ \inserttocsection}
\setbeamertemplate{subsection in toc}{\hspace*{1.5em}\parbox[t]{0.75\textwidth}{\raggedright\footnotesize\textendash\ \inserttocsubsection}}

\title{Magic State Distillation From Quadratic Residue based CSS codes}
\subtitle{Placeholder Subtitle}
\author{Mihir Talati, Leonardo S.P Velloso}
\date{\today}

\begin{document}

\maketitle

\section{Presentation Outline}
\begin{frame}{Presentation Outline}
  \begin{columns}[t,onlytextwidth]
    \column{0.48\textwidth}
      \tableofcontents[sections={2-3},subsectionstyle=show/show,subsubsectionstyle=hide]
    \column{0.48\textwidth}
      \tableofcontents[sections={4-6},subsectionstyle=show/show,subsubsectionstyle=hide]
  \end{columns}
\end{frame}

\section{Background}
\subsection{Magic State Distillation Overview}
\begin{frame}{Magic State Distillation Overview}
  \begin{itemize}
    \item Fault-Tolerant QC: In many stabilizer codes, Clifford gates are transversal while $T$ is not 
    \vspace{10pt}
    \item Applying $T \longrightarrow$ spreads error $\longrightarrow$ \textbf{NOT FAULT-TOLERANT}  
\end{itemize}
\end{frame}
\begin{frame}{Motivation}
    \begin{itemize}
    \item Motivation:
    \vspace{5pt}
    \begin{enumerate}[i)]
        \item Universal Gate Set $\longrightarrow$ we want "net effect" of a $T$ gate without actually using it
        \vspace{10pt}
        \item MS Distillation $\longrightarrow$ "refining" imperfect magic states 
        \vspace{10pt}
        \item Measurements $+$ Clifford Operations $\longrightarrow$ Better MS
        \vspace{10pt} 
    \item Higher fidelity
    \end{enumerate}
  \end{itemize}
\end{frame}


\subsection{Transversal Gates}
\begin{frame}{Transversal Gatesets Background}
\begin{block}{Transversal Gate} \vspace{1pt}
A quantum operation $\mathcal{F}$ acting on $m$ blocks ($n$ qubits per block) is called transversal if it can be written as a tensor product of gates $G_i$, i.e 
$$\mathcal{F} = \bigotimes_{i=1}^n G_i$$ where \begin{itemize}
    \item $G_i$ acts on the $i^{th}$ qubit of each block
    \item ${G_i}$ acts on an $m$-qubit space (one qubit from each of the $m$ blocks)
    \item No $G_i$ ever touches more than one qubit in the same block
\end{itemize}
\end{block}
\end{frame}

\begin{frame}{Example: CNOT Gate}
    \begin{center}
        \includegraphics[scale=.3]{CnotTransversal.png}
    \end{center}
\end{frame}

\begin{frame}{Transversal Gatesets Background}
    \begin{itemize}
        \item Properties for Fault-Tolerant Quantum Computing:
        \vspace{5pt}
        \begin{enumerate}[i)]
            \item GPP -- Applying gate  avoids error blow-up inside the block
            \vspace{5pt}
            \item GCP -- makes the codes' correctable errors behave nicely through the gate
        \end{enumerate}
        \end{itemize}
\end{frame}

\begin{frame}{Constraints Imposed by Transversal Gates}
\begin{itemize}
    \item \textbf{Eastin--Knill Theorem:}  
    No QECC can realize a universal gate set using only transversal gates.
    \vspace{10pt}
    \item Transversal gates preserve the structure of stabilizer codes:
    they map Pauli errors to Pauli errors (GCP).
\end{itemize}
\end{frame}
\begin{frame}{Constraints Continued}
\begin{itemize}
    \item Logical gates implementable transversally are restricted to a 
    \textbf{finite subgroup} of the Clifford hierarchy.
    \vspace{10pt}
    \item Non-Clifford logical gates (e.g.\ $T$) cannot be implemented
    transversally in standard codes $\Rightarrow$ need magic states.
\end{itemize}
\end{frame}


\begin{frame}{CSS Codes (Quick View)}
\begin{itemize}
  \item Two classical codes: 
  $$ C_Z \subset C_X \subset \{0,1\}^n $$
  \item Encode: 
    $$ k = \dim(C_X) - \dim(C_Z)$$
  \item Logical states:
  $$|x + C_Z\rangle $$
  \item Error separation:
  \begin{itemize}
    \item $C_Z$ $\rightarrow$ X (bit-flip) errors
    \item $C_X$ $\rightarrow$ Z (phase) errors
  \end{itemize}
  \item $\Rightarrow$ Ideal for Pauli noise + distillation
\end{itemize}
\end{frame}


\subsection{Self-Dual Codes}
\subsection{Self-Dual Codes}
\begin{frame}{Self-Dual Codes}
\begin{itemize}
  \item Self-dual condition:
   $$ C = C^\perp$$
  \item $\Rightarrow$ Same code generates X and Z stabilizers
  \item $\Rightarrow$ Perfect X/Z symmetry
  \item $\Rightarrow$ Transversal Cliffords (e.g., $H$, sometimes CNOT)
  \item $\Rightarrow$ Very useful for distillation
\end{itemize}
\end{frame}

\subsection{Doubled QR Codes}
\begin{frame}{Doubled QR Codes: Construction}
\begin{itemize}
  \item Input ingredients:
  \begin{itemize}
    \item Self-dual, doubly-even CSS code  
    $\Rightarrow$ X/Z symmetry, transversal Cliffords
    \item QR-derived doubly-even CSS code  
    $\Rightarrow$ High distance
  \end{itemize}
  \vspace{6pt}
  \item Apply \textbf{doubling map}
  \item $\Rightarrow$ Weakly triply-even, high-performance distillation codes
\end{itemize}
\end{frame}

\begin{frame}{Doubled QR Codes: Construction Summary}    
\begin{itemize}
    \item Resulting code $\longrightarrow$ \textbf{weakly triply-even} (mulitple of 8) 
    \vspace{5pt}
    \item Enables transversal $T$
    \vspace{5pt}
    \item High Distance
    \vspace{5pt}
    \item Low overhead
  \end{itemize}
  \end{frame}
  \begin{frame}{Codes Diagram}
      \begin{center}
      \includegraphics[scale = .4]{ScreenshotCodes.png}
      \end{center}
  \end{frame}
\subsection{Distillation Protocol}
\begin{frame}{Bravyi--Haah Magic State Distillation}
  \begin{itemize}
    \item Uses \textbf{triorthogonal} (or weakly triply-even) CSS codes to distill high-fidelity $|T\rangle$ magic states
      \vspace{10pt}
    \item Input: multiple noisy copies of $|T\rangle$ with physical error rate $p$
      \vspace{10pt}
    \item Protocol applies only \textbf{Clifford operations} and \textbf{Pauli measurements} on the encoded blocks
  \end{itemize}
\end{frame}
\begin{frame}{Bravyi--Haah Magic State Distillation}
\begin{itemize}
    \item Output: a smaller number of magic states with error rate suppressed to $O(p^k)$ where $k$ depends on the code (Bravyi--Haah has $k \ge 3$) 
    \vspace{10pt}
    \item Assumptions: transversal Clifford gates available; code satisfies triorthogonality (and/or weak triply-even structure) for $T$

    \end{itemize}
\end{frame}

\section{Motivation and Approach}

\subsection{Methodology}
\begin{frame}{Bravyi-Haah Protocol for TE* and triorthogonal codes}
  \begin{itemize}
    \item Same BH protocol applied to each specific QR-based TE* code.
    \item Inputs:
      \begin{itemize}
        \item $H_X$ matrix (rows = X stabilizers),
        \item Logical-$Z$ vector $z_{\text{log}}$,
        \item Physical error rate $p$ on each T-state,
        \item Noise model: i.i.d.\ Z noise for magic state injection.
      \end{itemize}
    \item For each code:
      \[
      s(p) = \Pr[H_X e^T = 0], \qquad
      p_{\text{out}}(p) = \Pr[z_{\text{log}}\cdot e = 1 \mid \text{accepted}]
      \]
    \item We compute these numerically per-block.
  \end{itemize}
\end{frame}

\subsection{Hypothesis}
\begin{frame}{Hypothesis}
  \begin{itemize}
    \item TE* / QR-based codes have \textbf{better finite-size overhead} than:
      \begin{itemize}
        \item Standard BH triorthogonal codes,
        \item Generic doubled self-dual codes.
      \end{itemize}
    \item Due to:
      \begin{itemize}
        \item High distances at small $n$,
        \item Structure inherited from QR code weight distributions,
        \item Particularly low-weight X-checks satisfying mod-8 conditions.
      \end{itemize}
    \item Anticipated result:
      \begin{itemize}
        \item Better yield/overhead for $n \lesssim 30 \to 100$ (depending on how many we can simulate),
        \item But asymptotic exponent still $\gamma \to 2$.
      \end{itemize}
  \end{itemize}
\end{frame}

\subsection{Yield}
\begin{frame}{Distillation Yield}
  \begin{itemize}
    \item Yield quantifies “magic states out per magic state in”:
      \[
      Y(p) = \frac{k \cdot s(p)}{n}
      \]
    \item For Jain–Albert codes:
      \begin{itemize}
        \item Typically $k=1$ so $Y = s(p)/n$.
        \item Small and medium $n$ have surprisingly high yields due to small block sizes.
      \end{itemize}
    \item Comparison baseline:
      \begin{itemize}
        \item Bravyi–Haah triorthogonal families ($n = 3k + 8$),
        \item Self-dual doubled families used in prior constructions.
      \end{itemize}
  \end{itemize}
\end{frame}

\subsection{Scaling}
\begin{frame}{Scaling With Code Length}
  \begin{itemize}
    \item Key theoretical fact from Jain–Albert:
      \[
      d(n) \approx \Theta(\sqrt{n})
      \]
      for both TE* and triorthogonal families constructed.
    \item For a BH-style distillation:
      \[
      p_{\text{out}}(p) \sim C p^\alpha, \quad \alpha \approx d_Z
      \]
      where $d_Z$ = minimum weight undetected Z logical error.
    \item Thus,
      \[
      \alpha(n) \approx \Theta(\sqrt{n})
      \]
    \item But:
      \[
      \gamma_n = \log_\alpha(n/k) \to 2
      \]
      meaning asymptotically the codes do not beat BH’s $1.585$ exponent.
    \item However: \textbf{finite-size performance may be significantly better}.
  \end{itemize}
\end{frame}

\section{Simulation}
\subsection{Algorithm}
\begin{frame}{Algorithm Overview \; [WIP]}
  \begin{itemize}
    \item For each code:
      \begin{enumerate}
        \item Import $H_X$ and logical-$Z$.
        \item Sample error patterns $e \sim \text{Bernoulli}(p)^n$.
        \item Check acceptance: $H_X e^T = 0$.
        \item For accepted blocks, compute logical parity $z_{\text{log}}\cdot e$.
      \end{enumerate}
    \item Metrics:
      \[
      s(p) = \frac{\text{accepted}}{N},
      \quad 
      p_{\text{out}}(p) = \frac{\text{harmful and accepted}}{\text{accepted}},
      \quad 
      Y = \frac{s(p)}{n}
      \]
    \item $Y$ is a proxy for approximate per code distillation yield

    \item Complexity:
      \begin{itemize}
        \item Monte Carlo: $O(Nrn)$ for $r$ stabilizers.
        \item Exhaustive enumeration for small $n$ to compute $\alpha$ exactly.
      \end{itemize}
  \end{itemize}
\end{frame}

\subsection{Results}
\begin{frame}{Pretty Graphs}
  \begin{itemize}
    \item Placeholder description of the simulation setup and noise models.
    \item Mention computational tools or libraries anticipated for the study.
  \end{itemize}
\end{frame}

\subsection{Analysis}
\begin{frame}{Contextualizing Results}
  \begin{itemize}
    \item Placeholder interpretation of simulated performance metrics.
    \item Discussion points comparing outcomes to expectations or baselines.
  \end{itemize}
\end{frame}

\section{Conclusion}
\begin{frame}{HYpothesis vs Results}
  \begin{itemize}
    \item Placeholder statement of the working hypothesis before analysis.
    \item Criteria used to judge success or failure.
  \end{itemize}
\end{frame}

\section{Potential Future Work}
\begin{frame}{What's next?}
  \begin{itemize}
    \item Placeholder list of follow-up experiments and protocol refinements.
    \item Suggestions for code design or distillation strategy improvements.
  \end{itemize}
\end{frame}

\end{document}
