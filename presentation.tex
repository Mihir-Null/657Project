\documentclass[aspectratio=169]{beamer}
\usetheme{metropolis}

\setbeamertemplate{section in toc}{\textbullet\ \inserttocsection}
\setbeamertemplate{subsection in toc}{\hspace*{1.5em}\parbox[t]{0.75\textwidth}{\raggedright\footnotesize\textendash\ \inserttocsubsection}}

\title{Magic State Distillation From Quadratic Residue based CSS codes}
\subtitle{Placeholder Subtitle}
\author{Mihir Talati, Leonardo S.P Velloso}
\date{\today}

\begin{document}

\maketitle

\section{Presentation Outline}
\begin{frame}{Presentation Outline}
  \begin{columns}[t,onlytextwidth]
    \column{0.48\textwidth}
      \tableofcontents[sections={2-3},subsectionstyle=show/show,subsubsectionstyle=hide]
    \column{0.48\textwidth}
      \tableofcontents[sections={4-6},subsectionstyle=show/show,subsubsectionstyle=hide]
  \end{columns}
\end{frame}

\section{Background}
\subsection{Magic State Distillation Overview}
\begin{frame}{Magic State Distillation Overview}
  \begin{itemize}
    \item Fault-Tolerant QC: In many stabilizer codes, Clifford gates are transversal while $T$ is not
    \item Applying $T \longrightarrow$ spreads error $\longrightarrow$ \textbf{NOT FAULT-TOLERANT} 
    \item Motivation:
    \begin{enumerate}[i)]
        \item Universal Gate Set $\longrightarrow$ we want "net effect" of a $T$ gate without actually using it
        \item Magic state distillation is the process of "refining" imperfect magic states 
        \item Sequence of Pauli measurements and Clifford group operations generate less, but better magic states
    \item Higher fidelity
    \end{enumerate}
  \end{itemize}
\end{frame}

\subsection{Transversal Gates}
\begin{frame}{Transversal Gatesets Background}
\begin{block}{Transversal Gate} \vspace{1pt}
A quantum operation $\mathcal{F}$ acting on $m$ blocks ($n$ qubits per block) is called transversal if it can be written as a tensor product of gates $G_i$, i.e 
$$\mathcal{F} = \bigotimes_{i=1}^n G_i$$ where \begin{itemize}
    \item $G_i$ acts on the $i^{th}$ qubit of each block
    \item ${G_i}$ acts on an $m$-qubit space (one qubit from each of the $m$ blocks)
    \item No $G_i$ ever touches more than one qubit in the same block
\end{itemize}
\end{block}
\end{frame}

\begin{frame}{Transversal Gatesets Background}
    \begin{itemize}
        \item Properties for Fault-Tolerant Quantum Computing:
        \begin{enumerate}[i)]
            \item GPP -- Applying gate  avoids error blow-up inside the block
            \item GCP -- makes the codes' correctable errors behave nicely through the gate
        \end{enumerate}
        \end{itemize}
\end{frame}

\begin{frame}{Constraints Imposed by Transversal Gates}
\begin{itemize}
    \item \textbf{Eastin--Knill Theorem:}  
    No QECC can realize a universal gate set using only transversal gates.
    \item Transversal gates preserve the structure of stabilizer codes:
    they map Pauli errors to Pauli errors (GCP).
    \item Logical gates implementable transversally are restricted to a 
    \textbf{finite subgroup} of the Clifford hierarchy.
    \item Non-Clifford logical gates (e.g.\ $T$) cannot be implemented
    transversally in standard codes $\Rightarrow$ need magic states.
\end{itemize}
\end{frame}


\begin{frame}{CSS Code Formalization}
  \begin{itemize}
    \item Built from two classical linear codes 
      $$C_Z \subset C_X \subset \{0,1\}^n.$$
    \item Encodes $k = \dim(C_X)-\dim(C_Z)$ logical qubits into $n$ physical qubits.
    \item Logical basis states are uniform superpositions over cosets: 
      $$|x + C_Z\rangle.$$
    \item Error structure splits cleanly through stabilizers:
      \begin{itemize}
        \item $C_Z$ corrects bit-flip (X) errors
        \item $C_X$corrects phase-flip (Z) errors
      \end{itemize}
    \item Useful in distillation: Pauli-type noise handled independently, supports some Clifford Gates
  \end{itemize}
\end{frame}

\subsection{Self-Dual Codes}
\begin{frame}{Self-Dual Codes}
  \begin{itemize}
    \item A CSS code is \textbf{self-dual} if its classical code satisfies 
      $$C = C^\perp$$
    \item Then the $X$ and $Z$-stabilizers come from the same linear code
    \item This creates strong X/Z symmetry in the error structure
    \item Such symmetry allows more Clifford gates to be transversal (e.g., $H$, sometimes CNOT), which is useful for distillation
  \end{itemize}
\end{frame}
\subsection{Doubled QR Codes}
\begin{frame}{Doubled QR Codes: Construction Summary}
  \begin{itemize}
    \item Begin with two ingredients:
    \begin{itemize}
        \item a \textbf{self-dual, doubly-even} (Hamming weight is multiple of 4) CSS code (gives X/Z symmetry and transversal Cliffords)
        \item a \textbf{QR-derived doubly-even} CSS code (provides high distance)
    \end{itemize}
    \item Apply a \textbf{doubling map} to combine these two codes
    \item The resulting code is \textbf{weakly triply-even} (mulitple of 8), enabling a transversal logical $T$ gate.
    \item Final product: a family of $[n,1,d]$ codes with high distance and lower qubit overhead for transversal Clifford and $T$
  \end{itemize}
  \end{frame}
  \begin{frame}{Codes Diagram}
      %\begin{center}\includegraphics[scale = .4]{Screenshot 2025-12-02 at 13.23.20.png}%\end{center}
      %% Leo, the screenshot needs to be uploaded in the folder
  \end{frame}
\subsection{Distillation Protocol}
\begin{frame}{Bravyi--Haah Magic State Distillation}
  \begin{itemize}
    \item Uses \textbf{triorthogonal} (or weakly triply-even) CSS codes to distill high-fidelity $|T\rangle$ magic states
    \item Input: multiple noisy copies of $|T\rangle$ with physical error rate $p$
    \item Protocol applies only \textbf{Clifford operations} and \textbf{Pauli measurements} on the encoded blocks
    \item Output: a smaller number of magic states with error rate suppressed to $O(p^k)$ where $k$ depends on the code (Bravyi--Haah has $k \ge 3$)
    \item Assumptions: transversal Clifford gates available; code satisfies triorthogonality (or weak triply-even structure) for logical $T$
    \item Target: preparation of high-fidelity logical $|T\rangle$ states for universal FTQC.
  \end{itemize}
\end{frame}


\section{Motivation and Approach}

\subsection{Methodology}
\begin{frame}{Bravyi-Haah Protocol for TE* and triorthogonal codes}
  \begin{itemize}
    \item Same BH protocol applied to each specific QR-based TE* code.
    \item Inputs:
      \begin{itemize}
        \item $H_X$ matrix (rows = X stabilizers),
        \item Logical-$Z$ vector $z_{\text{log}}$,
        \item Physical error rate $p$ on each T-state,
        \item Noise model: i.i.d.\ Z noise for magic state injection.
      \end{itemize}
    \item For each code:
      \[
      s(p) = \Pr[H_X e^T = 0], \qquad
      p_{\text{out}}(p) = \Pr[z_{\text{log}}\cdot e = 1 \mid \text{accepted}]
      \]
    \item We compute these numerically per-block.
  \end{itemize}
\end{frame}

\subsection{Hypothesis}
\begin{frame}{Hypothesis}
  \begin{itemize}
    \item TE* / QR-based codes have \textbf{better finite-size overhead} than:
      \begin{itemize}
        \item Standard BH triorthogonal codes,
        \item Generic doubled self-dual codes.
      \end{itemize}
    \item Due to:
      \begin{itemize}
        \item High distances at small $n$,
        \item Structure inherited from QR code weight distributions,
        \item Particularly low-weight X-checks satisfying mod-8 conditions.
      \end{itemize}
    \item Anticipated result:
      \begin{itemize}
        \item Better yield/overhead for $n \lesssim 30 \to 100$ (depending on how many we can simulate),
        \item But asymptotic exponent still $\gamma \to 2$.
      \end{itemize}
  \end{itemize}
\end{frame}

\subsection{Yield}
\begin{frame}{Distillation Yield}
  \begin{itemize}
    \item Yield quantifies “magic states out per magic state in”:
      \[
      Y(p) = \frac{k \cdot s(p)}{n}
      \]
    \item For Jain–Albert codes:
      \begin{itemize}
        \item Typically $k=1$ so $Y = s(p)/n$.
        \item Small and medium $n$ have surprisingly high yields due to small block sizes.
      \end{itemize}
    \item Comparison baseline:
      \begin{itemize}
        \item Bravyi–Haah triorthogonal families ($n = 3k + 8$),
        \item Self-dual doubled families used in prior constructions.
      \end{itemize}
  \end{itemize}
\end{frame}

\subsection{Scaling}
\begin{frame}{Scaling With Code Length}
  \begin{itemize}
    \item Key theoretical fact from Jain–Albert:
      \[
      d(n) \approx \Theta(\sqrt{n})
      \]
      for both TE* and triorthogonal families constructed.
    \item For a BH-style distillation:
      \[
      p_{\text{out}}(p) \sim C p^\alpha, \quad \alpha \approx d_Z
      \]
      where $d_Z$ = minimum weight undetected Z logical error.
    \item Thus,
      \[
      \alpha(n) \approx \Theta(\sqrt{n})
      \]
    \item But:
      \[
      \gamma_n = \log_\alpha(n/k) \to 2
      \]
      meaning asymptotically the codes do not beat BH’s $1.585$ exponent.
    \item However: \textbf{finite-size performance may be significantly better}.
  \end{itemize}
\end{frame}

\section{Simulation}
\subsection{Algorithm}
\begin{frame}{Algorithm Overview \; [WIP]}
  \begin{itemize}
    \item For each code:
      \begin{enumerate}
        \item Import $H_X$ and logical-$Z$.
        \item Sample error patterns $e \sim \text{Bernoulli}(p)^n$.
        \item Check acceptance: $H_X e^T = 0$.
        \item For accepted blocks, compute logical parity $z_{\text{log}}\cdot e$.
      \end{enumerate}
    \item Metrics:
      \[
      s(p) = \frac{\text{accepted}}{N},
      \quad 
      p_{\text{out}}(p) = \frac{\text{harmful and accepted}}{\text{accepted}},
      \quad 
      Y = \frac{s(p)}{n}
      \]
    \item $Y$ is a proxy for approximate per code distillation yield

    \item Complexity:
      \begin{itemize}
        \item Monte Carlo: $O(Nrn)$ for $r$ stabilizers.
        \item Exhaustive enumeration for small $n$ to compute $\alpha$ exactly.
      \end{itemize}
  \end{itemize}
\end{frame}

\subsection{Results}
\begin{frame}{Pretty Graphs}
  \begin{itemize}
    \item Placeholder description of the simulation setup and noise models.
    \item Mention computational tools or libraries anticipated for the study.
  \end{itemize}
\end{frame}

\subsection{Analysis}
\begin{frame}{Contextualizing Results}
  \begin{itemize}
    \item Placeholder interpretation of simulated performance metrics.
    \item Discussion points comparing outcomes to expectations or baselines.
  \end{itemize}
\end{frame}

\section{Conclusion}
\begin{frame}{HYpothesis vs Results}
  \begin{itemize}
    \item Placeholder statement of the working hypothesis before analysis.
    \item Criteria used to judge success or failure.
  \end{itemize}
\end{frame}

\section{Potential Future Work}
\begin{frame}{What's next?}
  \begin{itemize}
    \item Placeholder list of follow-up experiments and protocol refinements.
    \item Suggestions for code design or distillation strategy improvements.
  \end{itemize}
\end{frame}

\end{document}
